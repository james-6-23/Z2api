# Z2API 部署指南

## 📋 概述

本指南涵盖三个API代理项目的部署策略：

- **Deno版本**: 基于TypeScript的DeepInfra代理
- **Go版本**: 优化的Go语言DeepInfra代理  
- **Z2API主项目**: 基于Go的Z.ai代理

## 🚀 快速开始

### Z2API主项目（推荐）

```bash
# 克隆仓库
git clone <repository-url>
cd Z2api/z2api

# 构建二进制文件
go build -o z2api main.go

# 使用默认设置运行
./z2api
```

### Go版本（生产就绪）

```bash
cd Z2api/go-version

# 构建优化的二进制文件
go build -ldflags="-s -w" -o go-proxy main.go

# 使用配置运行
export MAX_CONCURRENT_CONNECTIONS=1000
export ENABLE_DETAILED_LOGGING=true
./go-proxy
```

### Deno版本

```bash
cd Z2api/deno-version

# 安装Deno（如果未安装）
curl -fsSL https://deno.land/install.sh | sh

# 运行并授予权限
deno run --allow-net --allow-env app.ts
```

## ⚙️ 环境配置

### Z2API主项目配置

| 变量名 | 默认值 | 说明 |
|--------|--------|------|
| `PORT` | `:8080` | 服务器端口 |
| `UPSTREAM_URL` | `https://chat.z.ai/api/chat/completions` | Z.ai API端点 |
| `DEFAULT_KEY` | `123456` | API认证密钥 |
| `ANON_TOKEN_ENABLED` | `true` | 启用匿名token获取 |
| `THINK_TAGS_MODE` | `think` | 思考内容处理模式 |

### Go版本配置

| 变量名 | 默认值 | 说明 |
|--------|--------|------|
| `PORT` | `8000` | 服务器端口 |
| `PERFORMANCE_MODE` | `balanced` | 性能模式 (fast/balanced/secure) |
| `MAX_CONCURRENT_CONNECTIONS` | `1000` | 最大并发连接数 |
| `ENABLE_DETAILED_LOGGING` | `true` | 启用结构化日志 |
| `STREAM_BUFFER_SIZE` | `16384` | 流缓冲区大小（字节） |

### Deno版本配置

| 变量名 | 默认值 | 说明 |
|--------|--------|------|
| `PORT` | `8000` | 服务器端口 |
| `PERFORMANCE_MODE` | `balanced` | 性能模式 |
| `DEEPINFRA_MIRRORS` | - | 逗号分隔的镜像端点 |
| `VALID_API_KEYS` | `linux.do` | 有效的API密钥 |

## 🐳 Docker部署

### Z2API主项目

```dockerfile
# Dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY . .
RUN go mod tidy
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o z2api main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/z2api .
EXPOSE 8080
CMD ["./z2api"]
```

```bash
# 构建和运行
docker build -t z2api .
docker run -p 8080:8080 -e DEFAULT_KEY=your-key z2api
```

### Go版本

```dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go-version/ .
RUN go mod init go-proxy
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o go-proxy main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/go-proxy .
EXPOSE 8000
CMD ["./go-proxy"]
```

### Deno版本

```dockerfile
FROM denoland/deno:alpine

WORKDIR /app
COPY deno-version/app.ts .

EXPOSE 8000
CMD ["run", "--allow-net", "--allow-env", "app.ts"]
```

## 🏭 生产环境部署

### 使用Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  z2api:
    build: 
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - DEFAULT_KEY=${API_KEY}
      - ANON_TOKEN_ENABLED=true
      - THINK_TAGS_MODE=think
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  go-proxy:
    build:
      context: .
      dockerfile: Dockerfile.go
    ports:
      - "8000:8000"
    environment:
      - PERFORMANCE_MODE=secure
      - MAX_CONCURRENT_CONNECTIONS=2000
      - ENABLE_DETAILED_LOGGING=true
    restart: unless-stopped
```

### Kubernetes部署

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: z2api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: z2api
  template:
    metadata:
      labels:
        app: z2api
    spec:
      containers:
      - name: z2api
        image: z2api:latest
        ports:
        - containerPort: 8080
        env:
        - name: DEFAULT_KEY
          valueFrom:
            secretKeyRef:
              name: z2api-secret
              key: api-key
        resources:
          requests:
            memory: "64Mi"
            cpu: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: z2api-service
spec:
  selector:
    app: z2api
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer
```

## 🔄 反向代理配置

### Nginx配置

```nginx
# /etc/nginx/sites-available/z2api
upstream z2api_backend {
    server 127.0.0.1:8080;
    # 添加更多服务器进行负载均衡
    # server 127.0.0.1:8081;
}

server {
    listen 80;
    server_name your-domain.com;

    location / {
        proxy_pass http://z2api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # 流式响应配置
        proxy_buffering off;
        proxy_cache off;
        proxy_read_timeout 300s;
        proxy_connect_timeout 75s;
    }
}
```

### Caddy配置

```caddyfile
# Caddyfile
your-domain.com {
    reverse_proxy localhost:8080 {
        header_up X-Real-IP {remote_host}
        header_up X-Forwarded-For {remote_host}
    }
}
```

## 📊 监控和日志

### 健康检查端点

- **Z2API**: 当前无健康检查端点（需要实现）
- **Go版本**: `GET /health` - 返回系统状态
- **Deno版本**: `GET /health` - 返回性能指标

### 日志配置

```bash
# 启用详细日志
export ENABLE_DETAILED_LOGGING=true

# 记录到文件
./z2api 2>&1 | tee -a /var/log/z2api.log

# 使用jq解析JSON日志
tail -f /var/log/z2api.log | jq '.'
```

### Prometheus指标（Go版本）

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'z2api'
    static_configs:
      - targets: ['localhost:8000']
    metrics_path: '/metrics'
    scrape_interval: 15s
```

## ⚡ 性能调优

### 系统限制

```bash
# 增加文件描述符限制
echo "* soft nofile 65536" >> /etc/security/limits.conf
echo "* hard nofile 65536" >> /etc/security/limits.conf

# 内核参数
echo "net.core.somaxconn = 65536" >> /etc/sysctl.conf
echo "net.ipv4.tcp_max_syn_backlog = 65536" >> /etc/sysctl.conf
sysctl -p
```

### Go版本优化

```bash
# 生产环境变量
export PERFORMANCE_MODE=secure
export MAX_CONCURRENT_CONNECTIONS=2000
export STREAM_BUFFER_SIZE=32768
export REQUEST_TIMEOUT=120000
export STREAM_TIMEOUT=600000
```

### Z2API优化

```bash
# 推荐设置
export ANON_TOKEN_ENABLED=true
export THINK_TAGS_MODE=think
# 实现后添加更多配置选项
```

## 🔒 安全考虑

### API密钥管理

```bash
# 使用环境变量
export DEFAULT_KEY="$(openssl rand -hex 32)"

# 或使用Docker secrets
echo "your-secure-key" | docker secret create api_key -
```

### 网络安全

```bash
# 防火墙规则（UFW）
ufw allow 22/tcp
ufw allow 80/tcp
ufw allow 443/tcp
ufw deny 8080/tcp  # 阻止直接访问
ufw enable
```

### SSL/TLS配置

```nginx
# Nginx SSL配置
server {
    listen 443 ssl http2;
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    # 现代SSL配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
}
```

## 🔧 故障排除

### 常见问题

1. **端口已被占用**
   ```bash
   lsof -i :8080
   kill -9 <PID>
   ```

2. **权限被拒绝**
   ```bash
   sudo setcap 'cap_net_bind_service=+ep' ./z2api
   ```

3. **内存问题**
   ```bash
   # 监控内存使用
   top -p $(pgrep z2api)
   ```

### 调试模式

```bash
# 启用调试日志
export DEBUG_MODE=true
./z2api
```

## 💾 备份和恢复

### 配置备份

```bash
# 备份环境变量
env | grep -E "(DEFAULT_KEY|UPSTREAM_TOKEN)" > .env.backup

# 备份二进制文件
cp z2api z2api.backup.$(date +%Y%m%d)
```

### 日志轮转

```bash
# 设置logrotate
cat > /etc/logrotate.d/z2api << EOF
/var/log/z2api.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    copytruncate
}
EOF
```

## 📈 性能基准

### 推荐硬件配置

| 场景 | CPU | 内存 | 磁盘 | 网络 |
|------|-----|------|------|------|
| **开发环境** | 2核 | 2GB | 20GB | 100Mbps |
| **小型生产** | 4核 | 4GB | 50GB | 1Gbps |
| **大型生产** | 8核+ | 16GB+ | 100GB+ | 10Gbps |

### 并发性能预估

- **Z2API主项目**: ~2000 req/s
- **Go版本**: ~5000 req/s  
- **Deno版本**: ~1000 req/s

## 🎯 最佳实践

1. **使用反向代理**：Nginx或Caddy
2. **启用HTTPS**：Let's Encrypt证书
3. **监控日志**：结构化日志 + 日志聚合
4. **定期备份**：配置和数据
5. **性能监控**：Prometheus + Grafana
6. **安全更新**：定期更新依赖和系统
